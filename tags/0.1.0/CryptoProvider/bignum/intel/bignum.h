
#ifndef _BIGNUM_HEADER_FILE
#define _BIGNUM_HEADER_FILE

#include "ippcp.h"
#include <iostream>

// функция создает большое число и инициализирует его
// параметры:
//		size	- размер числа в 32-битных словах
//		pData	- масссив 32-битных слов длины size, содержащий инициализирующее значение
// замечания:
//		- функция выделяет память под число, которую необходимо освободить функцией bnRelease()
IppsBigNumState* bnNew(const int size, const Ipp32u* pData=0);

// функция создает большое число и инициализирует его
// параметры:
//		sBN		- строковое шестнадцатеричное представление числа
//		size	- размер числа в 32-битных словах
// замечания:
//		- функция выделяет память под число, которую необходимо освободить функцией bnRelease()
IppsBigNumState* bnNew(const char* sBN, const int size);

// функция создает большое число и инициализирует его
// параметры:
//		size	- размер числа в 32-битных словах
//		pData	- масссив байтов, содержащий инициализирующее значение
// замечания:
//		- функция выделяет память под число, которую необходимо освободить функцией bnRelease()
IppsBigNumState* bnNew(const int size, const Ipp8u *pData);

// получение побайтового представления числа
// параметры:
//		pBN		- указатель на число, представление которого получаем
//		pBuf	- указатель на буфер, который будет содержать 16-ричное 
//					побайтовое представление числа
// замечание:
//		- память под буфер не выделяется
void bnGet(const IppsBigNumState* pBN, Ipp8u* pBuf, const int iBufSize);

// установка значения числа
// параметры:
//		pBN		- указатель на число, значение которого устанавливается
//		sBN		- строковое шестнадцатеричное представление числа
void bnSet( IppsBigNumState *pBN, const char * sBN);

// функция копирует большое число
// параметры:
//		pDest	- адрес по которому копируеться число (приемник), 
//					память заранее должна быть выделенна
//		pSource	- большое число которое надо скопировать (источник)
//		size	- размер числа в 32-битных словах
// замечания:
//		- НЕ происходит автоматического выделения памяти
void bnCopy(IppsBigNumState *pDest, const IppsBigNumState *pSource, const int size);

// сложение двух длинных чисел
// параметры
//		pA, pB	- слагаемые
//		pRes	- результат (контекст должен быть инициализирован заранее)
void bnAdd(IppsBigNumState* pA, IppsBigNumState* pB, IppsBigNumState* pRes );

// сложение двух длинных чисел
// параметры
//		pA		- уменьшаемое
//		pB		- вычитаемое
//		pRes	- результат (контекст должен быть инициализирован заранее)
void bnSub(IppsBigNumState* pA, IppsBigNumState* pB, IppsBigNumState* pRes );


// вывод числа в поток
std::ostream& operator<<(std::ostream& os, const IppsBigNumState* pBN);

// вывод в поток ошибки интеловской библиотеки
std::ostream& operator<<(std::ostream& os, const IppStatus ips);

// получает строковое шестнадцатиричное представление числа
// параметры:
//		sBN		- адрес буффера куда будет записано 
//					строковое представление.
//		pBN		- длинное число, чье строковое представление ищется.
// возвращает:
//		true, если представление получено и успешно записаео в буффер.
//		false в противном случае.
// замечание:
//		-	память автоматически не выделяется.
bool bnConvertToString ( const IppsBigNumState *pBN, char* sBN );

// освобождает память, занимаемую контекстом большого числа
// параметры:
//		pBN		- казатель число, контест которого освобождается
// замечание:
//		- указатель на число устанавливается в NULL
void bnRelease( IppsBigNumState *pBN );

// функция переводит строку с шестнадцатиричной записью числа (без префиксов '0x')
//	 в массив Ipp8u содержащий побайтовое представление числа (octet strings)
// параметры:
//		sChar	- строковое шестнадцатеричное представление числа
//		sOctet	- массив, содержащий побайтовое представление числа (octet strings)
void strtoIpp8u( Ipp8u* sOctet, const char* sChar);

#endif

